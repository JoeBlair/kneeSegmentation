import scipy.io as io
import numpy as np
import os
from scipy.ndimage import morphology
import os
from joblib import Parallel, delayed

def get_paths(path):

    path = path
    listing = os.listdir(path)
    paths = np.empty([0])

    for i in listing:

        paths = np.hstack((paths, str(path + '/' + i)))

    return paths

def Sampling(image_path):
    """
    :param image_path: path to image generated by get_paths
    :param patch_sizes: a list or array of patch sizes desired for convolution. Must be odd > 1.
    :param total_sample_size: sampled patches for convolution, and corresponding labels
    :return: sampled patches for convolution, and corresponding labels
    """

    # Load image from path
    Image = io.loadmat(image_path)
    # Extract total number of voxels
    Dims = np.prod(Image['scan'].shape)
    # Create 1 mask image
    Label = (Image['Tibia'] + 2*Image['Femur'])
    np.place(Label, Label>2, [2,1])

    if Image['isright'] == 0:

        Scan = np.fliplr(Image["scan"])
        Label = np.fliplr(Label)

    else: Scan = Image["scan"]

    Label2 = (Image['Tibia'] + Image['Femur'])

    B = morphology.distance_transform_cdt(np.absolute(Label2-1))
    B = B.reshape(Dims)
    X =  np.float32(range(np.max(B), 3, -1))/range(4, np.max(B)+1, 1)

    No_samples = 18000
    Index = np.array([])
    samples = np.divide(X, sum(X))*No_samples

    for i in range(4, np.max(B)+1):

        Index = np.int32(np.append(Index, np.random.choice(np.squeeze(np.where(B == i)),(samples[i-4]), replace=False)))

    Label = Label.reshape(Dims)

    # Find indexes of voxels to sample
    Gold_ind = np.squeeze(np.where(Label == 1))
    Silv_ind = np.squeeze(np.where(Label == 2))
    Edge_ind = np.squeeze(np.where((B>0) & (B<=2)))


    Index = np.hstack((Gold_ind, Silv_ind, Edge_ind, Index))

    np.random.shuffle(Index)

    Inds =  np.asarray(np.unravel_index(Index, Scan.shape, order = 'C'))

    Label_Sample = Label[Index]

    return Scan, Label_Sample,  Inds.T


def Patch_3D(image, indeces, patch_size):


    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(image['scan'], pad_width=n, mode='constant', constant_values = 0)

    Patches = np.array([])

    for i in range(0, len(indeces)):

        Patches = np.float32(np.append(Patches, (image_pad[indeces[i][0]:indeces[i][0]+m,indeces[i][1]:indeces[i][1]+m,indeces[i][2]:indeces[i][2]+m])))

    return Patches

def Patch_triplanar(image_path, patch_size):

    Image, Label, indeces =  Sampling(image_path)

    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values = 0)

    XY_Patches = np.array([])
    XZ_Patches = np.array([])
    YZ_Patches = np.array([])

    for i in range(0, len(indeces)):

        XY_Patches = np.float32(np.append(XY_Patches, (image_pad[indeces[i][0]:indeces[i][0]+m, indeces[i][1]:indeces[i][1]+m,  indeces[i][2]])))
        XZ_Patches = np.float32(np.append(XZ_Patches, (image_pad[indeces[i][0]:indeces[i][0]+m, indeces[i][1],                  indeces[i][2]:indeces[i][2]+m])))
        YZ_Patches = np.float32(np.append(YZ_Patches, (image_pad[indeces[i][0],                 indeces[i][1]:indeces[i][1]+m,  indeces[i][2]:indeces[i][2]+m])))

    XY_Patches =  XY_Patches.reshape(len(indeces), 1, m, m)
    XZ_Patches =  XZ_Patches.reshape(len(indeces), 1, m, m)
    YZ_Patches =  YZ_Patches.reshape(len(indeces), 1, m, m)

    Label = np.int32(Label.reshape(len(Label)))

    return XY_Patches, XZ_Patches, YZ_Patches, Label

def Tri_Image_Load(path, patch_size):

    PS = (patch_size - 1) / 2
    npad = ((PS, PS), (PS, PS), (PS,PS))
    window_size = (patch_size, patch_size, patch_size)

    A = io.loadmat(path)

    image_pad = np.pad(A['scan'], pad_width=npad, mode='constant', constant_values = 0)
    Nd = np.prod(A['scan'].shape)

    Label = (A['Tibia'] + 2*A['Femur']).reshape(Nd)
    indeces = np.squeeze(np.where(Label >= 0))

    for i in range(0, len(indeces)):

        XY_Patches = np.float32(np.append(XY_Patches, (image_pad[indeces[i][0]:indeces[i][0]+m, indeces[i][1]:indeces[i][1]+m,  indeces[i][2]])))
        XZ_Patches = np.float32(np.append(XZ_Patches, (image_pad[indeces[i][0]:indeces[i][0]+m, indeces[i][1],                  indeces[i][2]:indeces[i][2]+m])))
        YZ_Patches = np.float32(np.append(YZ_Patches, (image_pad[indeces[i][0],                 indeces[i][1]:indeces[i][1]+m,  indeces[i][2]:indeces[i][2]+m])))

    XY_Patches =  XY_Patches.reshape(len(indeces), 1, m, m)
    XZ_Patches =  XZ_Patches.reshape(len(indeces), 1, m, m)
    YZ_Patches =  YZ_Patches.reshape(len(indeces), 1, m, m)


    return XY_Patches, XZ_Patches, YZ_Patches, Label


def frame(indeces, image_pad, m):

    XY_Patches = np.float32(image_pad[indeces[0]:indeces[0]+m, indeces[1]:indeces[1]+m,  indeces[2]])
    XZ_Patches = np.float32(image_pad[indeces[0]:indeces[0]+m, indeces[1],                  indeces[2]:indeces[2]+m])
    YZ_Patches = np.float32(image_pad[indeces[0],                 indeces[1]:indeces[1]+m,  indeces[2]:indeces[2]+m])

    return XY_Patches, XZ_Patches, YZ_Patches


def Patch_triplanar_para(image_path, patch_size):

    Image, Label, indeces =  Sampling(image_path)

    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values = 0)

    # A, B, C = frame(indeces, image_pad, m)
    A = Parallel(n_jobs= 1)(delayed(frame)(i, image_pad, m) for i in indeces)
    A = np.array(A)
    Label = np.int32(Label.reshape(len(Label)))

    R, T, Y =  np.hsplit(A, 3)

    return R, T, Y, Label


def frame_3D(indeces, image_pad, m):

    Patches = np.float32(image_pad[indeces[0]:indeces[0]+m,indeces[1]:indeces[1]+m,indeces[2]:indeces[2]+m])

    return Patches

def Patch_3D_para(image_path, patch_size):

    Image, Label, indeces =  Sampling(image_path)

    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values = 0)
    Label = np.int32(Label.reshape(len(Label)))

    A = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad, m) for i in indeces)
    A = np.array(A)

    return A.reshape(len(indeces), 1, m, m ,m), Label, np.float32(indeces)
