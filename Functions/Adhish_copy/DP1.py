import scipy.io as io
import numpy as np
import os
from scipy.ndimage import morphology
from joblib import Parallel, delayed
import gc

def get_paths(path):

    path = path
    listing = os.listdir(path)
    paths = np.empty([0])

    for i in listing:

        paths = np.hstack((paths, str(path + '/' + i)))

    return paths

def Sampling(image_path):
    """
    :param image_path: path to image generated by get_paths
    :param patch_sizes: a list or array of patch sizes desired for convolution. Must be odd > 1.
    :param total_sample_size: sampled patches for convolution, and corresponding labels
    :return: sampled patches for convolution, and corresponding labels
    """

    # Load image from path
    Image = io.loadmat(image_path)
    # Extract total number of voxels
    Dims = np.prod(Image['scanROI'].shape)

    # Create 1 mask image
    Label = np.zeros(Image['scanROI'].shape)
    Label[Image['goldROI'] == 2] = 1

    Scan = Image["scanROI"]

    #max = np.array([0.9854,    0.7775,    0.6922])
    #min = np.array([0.4995,    0.1120,   0.0538])

    #xl, yl, zl =np.int32(np.around(np.multiply(Scan.shape, max)))
    #xu, yu, zu = np.int32(np.floor(np.multiply(Scan.shape, min)))

    #cropped = np.squeeze(np.where(Label[xu:xl, yu:yl, zu:zl] >= 0))
    #X = np.asarray([cropped[0] +xu, cropped[1]+yu , cropped[2] + zu])

 #   MM = np.ravel_multi_index(X, np.asarray(Scan.shape))
    B = morphology.distance_transform_cdt(np.absolute(Label-1))
    B = B.reshape(Dims)
 #  Gold_ind = np.squeeze(np.where(Label == 1 ))

#    X =  np.float32(range(np.max(B), 1, -1))/range(2, np.max(B)+1, 1)
#    No_samples = np.shape(Gold_ind)[1]
#    A = B[MM]
#    Index = np.array([])
#    samples = np.divide(X, sum(X))*No_samples
#    for i in range(2, np.max(A)):
#        Index = np.int32(np.append(Index, np.random.choice(np.squeeze(np.where(A == i)),(np.floor(samples)[i-1]), replace=False)))

    Label = Label.reshape(Dims)

    # Find indexes of voxels to sample
    Gold_ind = np.squeeze(np.where(Label ==1 ))
    Indeg = np.int32(np.random.choice(np.squeeze(Gold_ind), 1000, replace=False))

    P_ind = np.squeeze(np.where(np.logical_and(B>0, B<6)))
    Index = np.int32(np.random.choice(np.squeeze(P_ind), 1000, replace=False))
    Index = np.hstack((Index,  Indeg))
    np.random.shuffle(Index)
    
    Inds =  np.asarray(np.unravel_index(Index, Scan.shape, order = 'C'))
    Indie = Inds.reshape(3,1, Inds.shape[1]).T
    Label_Sample = Label[Index]
    
    return Scan,Label_Sample, Inds.T

def Patch_3D(image_path, patch_size):
    image, Label, indeces =  Sampling(image_path)

    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(image, pad_width=n, mode='constant', constant_values = 0)

    Patches = np.array([])

    for i in range(0, len(indeces)):

        Patches = np.float32(np.append(Patches, (image_pad[indeces[i][0]:indeces[i][0]+m,indeces[i][1]:indeces[i][1]+m,indeces[i][2]:indeces[i][2]+m])))

    return Patches

def Tri_Image_Load(path):

    A = io.loadmat(path)

    Label = np.zeros(A['goldROI'].shape)
    Label[A['goldROI'] == 2] = 1
    
    indeces = np.squeeze(np.where(Label >= 0))
    print indeces.shape
    indie = np.float32(indeces.reshape(3,1, indeces.shape[1]))
    return indeces.T, Label, A

def get_indeces(image_path):

    # Load image from path
    Image = io.loadmat(image_path)
    Label = np.zeros(Image['scanROI'].shape)


    Label[Image['goldROI'] == 2] = 1
    Scan = Image["scanROI"]
    Dims = np.prod(Scan.shape)

#    units = np.divide(Image['scanROI'].shape, 100.0)

 #   max = np.array([0.9854,    0.7775,    0.6922])
 #   min = np.array([0.4995,    0.1120,   0.0538])
 
#    xl, yl, zl = np.around(np.multiply(Scan.shape, max))
#    xu, yu, zu = np.int32(np.floor(np.multiply(Scan.shape, min)))
#    
#    cropped = np.squeeze(np.where(Label[xu:xl, yu:yl, zu:zl] >= 0))
#    X = np.asarray([cropped[0] +xu, cropped[1]+yu , cropped[2] + zu])    
    B = morphology.distance_transform_cdt(np.absolute(Label-1))
    B = B.reshape(Dims)
    X = np.squeeze(np.where(B < 6))
    Inds =  np.asarray(np.unravel_index(X, Scan.shape, order = 'C'))  

    return Inds.T, Label, Image



def frame(indeces, image_pad, m):
    D = ((m-1)/2)+1
    XY_Patches = np.float32(image_pad[indeces[0]:indeces[0]+m, indeces[1]:indeces[1]+m,  indeces[2]+D])
    XZ_Patches = np.float32(image_pad[indeces[0]:indeces[0]+m, indeces[1]+D,                  indeces[2]:indeces[2]+m])
    YZ_Patches = np.float32(image_pad[indeces[0]+D,                 indeces[1]:indeces[1]+m,  indeces[2]:indeces[2]+m])
    return XY_Patches, XZ_Patches, YZ_Patches

def frame_thick(indeces, image_pad, m):
    D = ((m-1)/2)+1
    XY_Patches = np.float32(image_pad[indeces[0]:indeces[0]+m, indeces[1]:indeces[1]+m,  indeces[2]+D-1:indeces[2]+D+2])
    XZ_Patches = np.float32(image_pad[indeces[0]:indeces[0]+m,  indeces[1]+D-1:indeces[1]+D+2, indeces[2]:indeces[2]+m])
    YZ_Patches = np.float32(image_pad[indeces[0]+D-1:indeces[0]+D+2, indeces[1]:indeces[1]+m,  indeces[2]:indeces[2]+m])
    n = np.array(XY_Patches)
    print n.shape
    return np.array(XY_Patches), np.array(XZ_Patches), np.array(YZ_Patches)

def frame_2D(indeces, image_pad, m):
    D = ((m-1)/2)+1
    XZ_Patches = np.float32(image_pad[indeces[0]:indeces[0]+m, indeces[1]+D,                  indeces[2]:indeces[2]+m])
    return  XZ_Patches


def Patch_planar_para(image_path, patch_size):

    Image, Label, indeces =  Sampling(image_path)

    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values = 0)

    A = Parallel(n_jobs= 1)(delayed(frame_2D)(i, image_pad, m) for i in indeces)
    A = np.array(A)
    Label = np.int32(Label.reshape(len(Label)))
    A = A.reshape(len(A), 1, m, m)

    return A,  Label


def Patch_triplanar_para(image_path, patch_size):

    Image, Label, indeces =  Sampling(image_path)

    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values = 0)

    A = Parallel(n_jobs= 1)(delayed(frame)(i, image_pad, m) for i in indeces)
    A = np.array(A)

    Label = np.int32(Label.reshape(len(Label)))
    XY, XZ, YZ =  np.hsplit(A, 3)
    return XY, XZ, YZ, Label

def Patch_thick_para(image_path, patch_size):

    Image, Label, indeces =  Sampling(image_path)

    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values = 0)
    print 'here'
    A = Parallel(n_jobs= 1)(delayed(frame_thick)(i, image_pad, m) for i in indeces)
    A = np.array(A)
    print A[1].shape
    Label = np.int32(Label.reshape(len(Label)))
    print Label.shape
       
    XY, XZ, YZ =  np.hsplit(A, 3)
    BOP = XY.reshape(41375, 3, 29, 29)
    print BOP.shape
    return XY, XZ, YZ, Label

def frame_3D(indeces, image_pad, m):

    Patches = np.float32(image_pad[indeces[0]:indeces[0]+m,indeces[1]:indeces[1]+m,indeces[2]:indeces[2]+m])

    return Patches

def Patch_3D_para(image_path, patch_size, P2):

    Image, Label, indeces =  Sampling(image_path)

    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values = 0)
    Label = np.int32(Label.reshape(len(Label)))

    A = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad, m) for i in indeces)
    A = np.array(A)

    n1 = (P2 -1)/2
    m1 =P2

    image_pad = np.pad(Image, pad_width=n1, mode='constant', constant_values = 0)

    B = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad, m1) for i in indeces)
    B = np.array(B)

    return A.reshape(len(indeces),1,  m, m ,m),B.reshape(len(indeces),1,  m1, m1 ,m1), Label


def Patch_thick(image_path, patch_size):

    Image, Label, indeces =  Sampling(image_path)

    n = (patch_size -1)/2
    m = patch_size+3

    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values = 0)
    XY_Patches = np.array([])
    XZ_Patches = np.array([])
    YZ_Patches = np.array([])
    D = ((m-1)/2)+1
    
    for i in range(0, len(indeces)):
        XY_Patches = np.float32(np.append(XY_Patches, (image_pad[indeces[i][0]:indeces[i][0]+m, indeces[i][1]:indeces[i][1]+m,  indeces[i][2]+D-1:indeces[i][2]+D+2])))
        XZ_Patches = np.float32(np.append(XZ_Patches, (image_pad[indeces[i][0]:indeces[i][0]+m,  indeces[i][1]+D-1:indeces[i][1]+D+2, indeces[i][2]:indeces[i][2]+m])))
        YZ_Patches = np.float32(np.append(YZ_Patches, (image_pad[indeces[i][0]+D-1:indeces[i][0]+D+2, indeces[i][1]:indeces[i][1]+m,  indeces[i][2]:indeces[i][2]+m])))
    XY_Patches =  XY_Patches.reshape(len(indeces), 3, m, m)
    XZ_Patches =  XZ_Patches.reshape(len(indeces), 3, m, m)
    YZ_Patches =  YZ_Patches.reshape(len(indeces), 3, m, m)

    Label = np.int32(Label.reshape(len(Label)))
    return XY_Patches, XZ_Patches, YZ_Patches, Label

def Patch_triplanar(image_path, patch_size):

    Image, Label, indeces =  Sampling(image_path)

    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values = 0)

    XY_Patches = np.array([])
    XZ_Patches = np.array([])
    YZ_Patches = np.array([])

    for i in range(0, len(indeces)):

        XY_Patches = np.float32(np.append(XY_Patches, (image_pad[indeces[i][0]:indeces[i][0]+m, indeces[i][1]:indeces[i][1]+m,  indeces[i][2]])))
        XZ_Patches = np.float32(np.append(XZ_Patches, (image_pad[indeces[i][0]:indeces[i][0]+m, indeces[i][1],                  indeces[i][2]:indeces[i][2]+m])))
        YZ_Patches = np.float32(np.append(YZ_Patches, (image_pad[indeces[i][0],                 indeces[i][1]:indeces[i][1]+m,  indeces[i][2]:indeces[i][2]+m])))

    XY_Patches =  XY_Patches.reshape(len(indeces), 1, m, m)
    XZ_Patches =  XZ_Patches.reshape(len(indeces), 1, m, m)
    YZ_Patches =  YZ_Patches.reshape(len(indeces), 1, m, m)

    Label = np.int32(Label.reshape(len(Label)))
    return XY_Patches, XZ_Patches, YZ_Patches, Label

def Patch_gen(indeces, patch_size, A):

    PS = (patch_size - 1) / 2
    npad = ((PS, PS), (PS, PS), (PS,PS))
    window_size = (patch_size, patch_size, patch_size)
    m = patch_size

    image_pad = np.pad(A['scanROI'], pad_width=npad, mode='constant', constant_values = 0)
    Nd = np.prod(A['scanROI'].shape)

    A = Parallel(n_jobs= 1)(delayed(frame)(i, image_pad, m) for i in indeces)
    A = np.array(A)


    R, T, Y =  np.hsplit(A, 3)

    return R, T, Y

def Patch_gen_three(indeces, patch_size,PS2, A):

    PS = (patch_size - 1) / 2
    npad = ((PS, PS), (PS, PS), (PS,PS))
    window_size = (patch_size, patch_size, patch_size)
    m = patch_size
    Image = A['scanROI']
    image_pad = np.pad(Image, pad_width=npad, mode='constant', constant_values = 0)
    Nd = np.prod(A['scanROI'].shape)

    A = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad, m) for i in indeces)
    R = np.array(A)

    n1 = (PS2 -1)/2
    npad = ((n1,n1), (n1, n1), (n1, n1))
    m1 = PS2

    image_pad = np.pad(Image, pad_width=npad, mode='constant', constant_values = 0)

    B = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad, m1) for i in indeces)
    B = np.array(B)



    return R.reshape(len(indeces),1, patch_size,patch_size,patch_size), B.reshape(len(indeces),1,m1,m1,m1)


def Patch_gen_mix(image_path):

    Image, Label, indeces =  Sampling(image_path)

    n3 = (9 -1)/2
    m3 = 9
    npad3 = ((n3, n3), (n3, n3), (n3, n3))
    image_pad3 = np.pad(Image, pad_width=npad3, mode='constant', constant_values = 0)

    A3 = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad3, m3) for i in indeces)
    A3 = np.array(A3)

    nine =  A3.reshape(len(indeces), 1, m3, m3 ,m3)

    n3 = (7 -1)/2
    m3 = 7
    npad3 = ((n3, n3), (n3, n3), (n3, n3))
    image_pad3 = np.pad(Image, pad_width=npad3, mode='constant', constant_values = 0)

    A3 = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad3, m3) for i in indeces)
    A3 = np.array(A3)

    seven =  A3.reshape(len(indeces), 1, m3, m3 ,m3)
    
    indie = indeces
    return nine, np.float32(indie.reshape(len(indeces), 1, 3 )), seven, np.int32(Label)



def Patch_mixed_para(image_path, patch_size):

    Image, Label, indeces =  Sampling(image_path)

    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values = 0)

    A = Parallel(n_jobs= 1)(delayed(frame)(i, image_pad, m) for i in indeces)
    A = np.array(A)
    Label = np.int32(Label.reshape(len(Label)))

    XY, XZ, YZ =  np.hsplit(A, 3)

    n3 = (9 -1)/2
    m3 = 9

    image_pad3 = np.pad(Image, pad_width=n3, mode='constant', constant_values = 0)
    Label3 = np.int32(Label.reshape(len(Label)))

    A3 = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad3, m3) for i in indeces)
    A3 = np.array(A3)

    three =  A3.reshape(len(indeces), 1, m3, m3 ,m3)


    return XY, XZ, YZ, three, Label
