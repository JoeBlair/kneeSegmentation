import nibabel as nib
import scipy.io as io
import numpy as np
from scipy.ndimage import morphology
import os
from joblib import Parallel, delayed


def get_paths(path):
    path = path
    listing = os.listdir(path)
    paths = np.empty([0])

    for i in listing:
        paths = np.hstack((paths, str(path + '/' + i)))

    return paths


def get_masks(path, path_L, path_R):

    lPath = path_L +"/" + path[-24:]
    rPath = path_R + "/" + path[-24:]

    leftMask = nib.load(lPath).get_data()
    rightMask = nib.load(rPath).get_data()
    mask = (leftMask*2) + rightMask
    return mask

def Sampling(image_path):
    """
    :param image_path: path to image generated by get_paths
    :param patch_sizes: a list or array of patch sizes desired for convolution. Must be odd > 1.
    :param total_sample_size: sampled patches for convolution, and corresponding labels
    :return: sampled patches for convolution, and corresponding labels
    """
    Image = io.loadmat(image_path)
    Scan = Image['Scan']
    Label = np.zeros(Image['Label'].shape)
    Label[Image['Label'] > 0] = 1
    Gold_ind = np.squeeze(np.where(Label>=1))
    Dims = np.prod(Scan.shape)
    B = morphology.distance_transform_cdt(np.absolute(Label - 1))
    B = B.reshape(Dims)
    X = np.float32(range(np.max(B), 1, -1)) / range(2, np.max(B) + 1, 1)
    No_samples = Gold_ind.shape[1]

    Index = np.array([])
    samples = np.divide(X, sum(X)) * No_samples

    for i in range(2, np.max(B)):
        Index = np.int32(
            np.append(Index, np.random.choice(np.squeeze(np.where(B == i)), (samples[i - 1]), replace=False)))

    Label = Label.reshape(Dims)
    Gold_ind = np.squeeze(np.where(Label>=1))
    # Find indexes of voxels to sample
    P_ind = np.squeeze(np.where(B == 1))
    Index = np.hstack((Gold_ind, Index, P_ind))
    np.random.shuffle(Index)
    Inds = np.asarray(np.unravel_index(Index, Scan.shape, order='C'))
    Label_Sample = Label[Index]
    return Scan, Label_Sample, Inds.T


def Patch_3D_para(image_path,L, R, patch_size, P2):

    Image, Label, indeces =  Sampling(image_path, L, R)

    n = (patch_size -1)/2
    m = patch_size

    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values = 0)
    Label = np.int32(Label.reshape(len(Label)))

    A = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad, m) for i in indeces)
    A = np.array(A)

    n1 = (P2 -1)/2
    m1 =P2

    image_pad = np.pad(Image, pad_width=n1, mode='constant', constant_values = 0)

    B = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad, m1) for i in indeces)
    B = np.array(B)

    return A.reshape(len(indeces),1,  m, m ,m),B.reshape(len(indeces),1,  m1, m1 ,m1), Label

def frame_3D(indeces, image_pad, m):
    Patches = np.float32(image_pad[indeces[0]:indeces[0] + m, indeces[1]:indeces[1] + m, indeces[2]:indeces[2] + m])

    return Patches


def Patch_triplanar_para(image_path,patch_size):
    Image, Label, indeces = Sampling(image_path)

    n = (patch_size - 1) / 2
    m = patch_size
    image_pad = np.pad(Image, pad_width=n, mode='constant', constant_values=0)

    A = Parallel(n_jobs=1)(delayed(frame)(i, image_pad, m) for i in indeces)
    A = np.array(A)

    Label = np.int32(Label.reshape(len(Label)))
    XY, XZ, YZ = np.hsplit(A, 3)

    return XY, XY, YZ, Label

def frame(indeces, image_pad, m):
    D = ((m - 1) / 2) + 1
    XY_Patches = np.float32(image_pad[indeces[0]:indeces[0] + m, indeces[1]:indeces[1] + m, indeces[2] + D])
    XZ_Patches = np.float32(image_pad[indeces[0]:indeces[0] + m, indeces[1] + D, indeces[2]:indeces[2] + m])
    YZ_Patches = np.float32(image_pad[indeces[0] + D, indeces[1]:indeces[1] + m, indeces[2]:indeces[2] + m])
    return XY_Patches, XZ_Patches, YZ_Patches




def get_indeces(image_path):

    # Load image from path
    Image = io.loadmat(image_path)
    Scan = Image['Scan']
    Label = np.zeros(Image['Label'].shape)
    Label[Image['Label'] > 0] = 1

    Dims = np.prod(Scan.shape)
    X = np.squeeze(np.where(Label>=0))
    return X.T, Label, Scan

def Patch_gen_three(indeces, patch_size,PS2, A):
    Image = A
    PS = (patch_size - 1) / 2
    npad = ((PS, PS), (PS, PS), (PS,PS))
    window_size = (patch_size, patch_size, patch_size)
    m = patch_size
    image_pad = np.pad(Image, pad_width=npad, mode='constant', constant_values = 0)
    Nd = np.prod(Image.shape)

    A = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad, m) for i in indeces)
    R = np.array(A)

    n1 = (PS2 -1)/2
    npad = ((n1,n1), (n1, n1), (n1, n1))
    m1 = PS2

    image_pad = np.pad(Image, pad_width=npad, mode='constant', constant_values = 0)

    B = Parallel(n_jobs= 1)(delayed(frame_3D)(i, image_pad, m1) for i in indeces)
    B = np.array(B)



    return R.reshape(len(indeces),1, patch_size,patch_size,patch_size), B.reshape(len(indeces),1,m1,m1,m1)

def Patch_gen(indeces, patch_size, A):
    PS = (patch_size - 1) / 2
    npad = ((PS, PS), (PS, PS), (PS, PS))
    window_size = (patch_size, patch_size, patch_size)
    m = patch_size
    image_pad = np.pad(A, pad_width=npad, mode='constant', constant_values=0)
    Nd = np.prod(A.shape)

    A = Parallel(n_jobs=1)(delayed(frame)(i, image_pad, m) for i in indeces)
    A = np.array(A)

    R, T, Y = np.hsplit(A, 3)

    return R, T, Y

